"""

This module is used to generate the simulation sequences required for the experiment

"""

import numpy as np
from numpy import random
from encode import encode_lc

def lc_sil(str_len, sil_num):
    """
    
    -------------------------------------------------------------
    Generate several random binary sequences and encode as DNA-LC.
    -------------------------------------------------------------

    param: str_len: the length of the binary sequence generated by the simulation.
           sil_num: number of simulations
    
    type: str_len: int
          sil_num: int

    Seed: random.seed(0)

    Test cases: 
    Input: str_len=7, sil_num=3
    Output(type: list): ['TGAGTGACTGTC', 'ACTGTGTCACTG', 'AGAGACAGAGAC']
    
    """
    dna_lc = []
    random.seed(0)
    list_rand_all = [[random.randint(0, 2) for _ in range(str_len)] for _ in range(sil_num)]
    for i in range(sil_num):
        dna_lc.append(encode_lc(list_rand_all[i]))
    return dna_lc

def hedges_sil(str_len, sil_num, runout_bytes):
    
    """

    ---------------------------------------------------------------
    Generate several random binary sequences for HEDGES(no encoding)
    ---------------------------------------------------------------

    param: str_len: the length of the binary sequence generated by the simulation.
           sil_num: number of simulations
    
    type: str_len: int
          sil_num: int

    Test cases: 
    Input: str_len=7, sil_num=3
    Output(type: list): [[0 1 1 0 1 1 1] 
                         [1 1 1 1 0 0 1] 
                         [0 0 0 0 0 1 0]]
    
    """
    random.seed(0)
    list_rand_all = [[random.randint(0, 2) for _ in range(str_len)] for _ in range(sil_num)]
    for i in range(len(list_rand_all)):
        list_rand_all[i].extend([0]*runout_bytes*8)
    dna_hedges = np.array(list_rand_all)

    return dna_hedges

def err_sil(error_prob, dna):

    """
    
    --------------------------------------------------------
    Accept the correct DNA sequences, and make random errors
    --------------------------------------------------------

    param: error_prob: The error probility for substitutions(p_sub), insertions
                       (p_ins) and deletions(p_del).
                       example: If you choose p_sub = p_ins = p_del = 0.01, you 
                       need to input [0.01, 0.01, 0.01]. 
           dna: the error-free dna sequences.

    type: error_prob: list
          dna: list

    Test Cases: 
    Input: error_prob = [0.1, 0.1, 0.1], dna = ['ACTG','ACAC']
    Output: ['ACTG','AAT']

    
    """
    str_len = len(dna[0])
    sil_num = len(dna)    
    err_free = 1 - sum(error_prob)
    prob = [error_prob[0], error_prob[1]/2, error_prob[1]/2, error_prob[2], err_free]
    seed_num = 0
    error_list = []
    error_list_all = []
    str_list_all = []
    for i in range(0, sil_num):
        for j in range(0,str_len):
            random.seed(seed_num)
            seed_num = seed_num + 1
            key = random.choice([1,2,3,4,0], p=prob)
            error_list.append(key)
        error_list_all.append(error_list)
        error_list = []

    for i in range(0, sil_num):
        l = 0
        str_list = list(dna[i])
        for j in range(0,str_len):
            if error_list_all[i][j] == 1:
                alpha = np.random.choice(['A','T','C','G'])
                str_list[j+l] = alpha
            elif error_list_all[i][j] == 2:
                alpha = np.random.choice(['A','T','C','G'])
                str_list.insert(j+l,alpha)
                l = l + 1
            elif error_list_all[i][j] == 3:
                alpha = np.random.choice(['A','T','C','G'])
                str_list.insert(j+l+1,alpha)
                l = l + 1
            elif error_list_all[i][j] == 4:
                del str_list[j+l]
                l = l - 1
        str_list = ''.join(str_list)
        str_list_all.append(str_list)
    return str_list_all


def err_sil_2(dna,num):

    """
    
    ------------------------------------------------------------------
    Accept the correct DNA sequences, and make inconsecutive deletions
    ------------------------------------------------------------------

    param: dna: the error-free dna sequences.
           num: the number of inconsecutive deletions

    type: dna: list
          num: int

    Test Cases: 
    Input: dna = ['AGTCTCTG'], num = 2
    Output: ['GTCCTG']

    
    """
    import random
    dna_len = len(dna[0])
    times = len(dna)
    str_list = []
    num_list = [random.sample(range(0,dna_len-num+1),num) for _ in range(times)]
    for a in num_list:
        a.sort()
        for i in range(len(a)):
            a[i] += i
    for i in range(0,times):
        str_list1 = list(dna[i])
        for j in range(0,num):
            str_list1[num_list[i][j]] = '0'
        for j in range(num):
            str_list1.remove('0')
        str_list1 = ''.join(str_list1)
        str_list.append(str_list1)
    return str_list


def err_sil_1(dna,num):
    """
    
    ------------------------------------------------------------------
    Accept the correct DNA sequences, and make deletions
    ------------------------------------------------------------------

    param: dna: the error-free dna sequences.
           num: the number of deletions

    type: dna: list
          num: int

    Test Cases: 
    Input: dna = ['AGTCTCTG'], num = 2
    Output: ['AGTCTC']

    
    """
    import random
    dna_len = len(dna[0])
    times = len(dna)
    str_list = []
    random.seed(0)
    num_list = [random.sample(range(0,dna_len),num) for _ in range(times)]
    for i in range(0,times):
        str_list1 = list(dna[i])
        for j in range(0,num):
            del str_list1[num_list[i][j]-j]
        str_list1 = ''.join(str_list1)
        str_list.append(str_list1)
    return str_list
